{"meta":{"title":"往者不可谏 来者犹可追","subtitle":"Stay Hungry，Stay Foolish","description":"","author":"ligang","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"netty","slug":"netty/netty","date":"2020-04-10T16:00:00.000Z","updated":"2020-04-11T11:44:39.255Z","comments":true,"path":"2020/04/11/netty/netty/","link":"","permalink":"http://yoursite.com/2020/04/11/netty/netty/","excerpt":"","text":"一个EventLoopGroup中包含一个或多个EventLoop 一个EventLoop在它的生命周期当中都只会与唯一一个Thread进行绑定 所有由EventLoop所处理的各种I/O事件都将在它所关联的Thread上进行处理 一个channel 在它的整个生命周期上只会注册到一个EventLoop上 一个EventLoop在运作过程中，会被分配给一个或多个channel netty中，channel的实现一定是线程安全的；基于此，我们可以存储一个channel的引用吗，并在需要向远程端点发送数据时，通过这个引用来调用channel相应的方法；即便当时有很多线程在使用它，也不会出现线程安全问题；而且，消息一定会按照顺序发出去。 重要结论：我们在开发业务中，不要将耗时任务放入EventLoop执行队列中，因为它将会一直阻塞该线程所对应的所有channel上的其他任务，如果我们需要进行阻塞调用或耗时的操作，就需要一个专门的EventExecutor（业务线程池）。通常有两种方法， 1在ChannelHander的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用； 2 借助于Netty提供的向ChannelPipeline添加ChannelHander时调用的addLast方法来传递EventExecutor， addLast 方法可以指定线程池 123456 // ChannelHander的回调方法都由I/O线程所执行， ChannelPipeline addLast(ChannelHandler... handlers);//ChannelHander的回调方法由group线程组来执行 ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers); 1、ChannelHanderContext与ChannelHander的关联绑定关系是永远不会发生改变的，因此对其进行缓存时没有任何问题的 2、对于Channel的同名方法来说，ChannelHanderContext的方法会产生更短的事件流，所以我们应该在可能的情况下利用这个特性来提升性能。 1234567 //在netty中有两种发消息的方式，1、可以直接写到Channel中 2、写到与ChannelHander所关联的 ChannelHanderContext中。 //消息会从ChannelPipeline的末尾开始流动ctx.channel().writeAndFlush(\"from Server\"+ UUID.randomUUID());//消息会从ChannelPipeline中的下一个ChannelHander开始流动ctx.writeAndFlush(\"\");","categories":[],"tags":[{"name":"netty","slug":"netty","permalink":"http://yoursite.com/tags/netty/"}],"keywords":[]},{"title":"G1收集器","slug":"jvm/垃圾回收器/G1垃圾收集器","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-01T15:12:16.464Z","comments":true,"path":"2020/04/01/jvm/垃圾回收器/G1垃圾收集器/","link":"","permalink":"http://yoursite.com/2020/04/01/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/","excerpt":"","text":"G1收集器Oracle官方文档 The heap is one memory area split into many fixed sized regions. The G1 Garbage Collector Step by Step1.G1 堆结构 ​ Heap 被划分为一个个相等的不连续的内存区域（regions）,每个region 都由一个分代的角色：eden、survivor、old；Region size is chosen by the JVM at startup. The JVM generally targets around 2000 regions varying in size from 1 to 32Mb. 在新生代满了时，会对整个新生代回收（要么回收，要么晋升），新生代也是分成region的原因是为了和老年代策略统一，方便调整代的大小。 堆每一个角色的数量没有强制的现拟定，也就是说对每一种分代内存的大小，可以动态的变化。","categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}],"keywords":[]},{"title":"G1收集器","slug":"jvm/诊断/jvm诊断","date":"2020-03-31T16:00:00.000Z","updated":"2020-04-01T15:28:34.800Z","comments":true,"path":"2020/04/01/jvm/诊断/jvm诊断/","link":"","permalink":"http://yoursite.com/2020/04/01/jvm/%E8%AF%8A%E6%96%AD/jvm%E8%AF%8A%E6%96%AD/","excerpt":"","text":"1.定位cpu过高 用top命令定位是哪个进程 ps H -eo pid,tid,%cpu |grep 进程id，或者 top -Hp 进程id jstack 进程id ,输出的线程是16进制的，上一步获取的线程是10进制的，要转化一下 2.运行很长得不到结果 jstack 最后面 3.OOM","categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}],"keywords":[]},{"title":"CMS收集器","slug":"jvm/垃圾回收器/CMS垃圾收集器","date":"2020-03-30T16:00:00.000Z","updated":"2020-03-31T17:23:24.570Z","comments":true,"path":"2020/03/31/jvm/垃圾回收器/CMS垃圾收集器/","link":"","permalink":"http://yoursite.com/2020/03/31/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/","excerpt":"","text":"Welcome to","categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}],"keywords":[]},{"title":"类加载过程","slug":"jvm/类加载/类加载过成","date":"2020-03-29T16:00:00.000Z","updated":"2020-04-11T16:41:50.384Z","comments":true,"path":"2020/03/30/jvm/类加载/类加载过成/","link":"","permalink":"http://yoursite.com/2020/03/30/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E6%88%90/","excerpt":"","text":"1、类加载 （Class Load） 在Java代码中，类型的加载，连接与初始化过程都是在程序 运行期间(Runtime) 完成的 提供更大的灵活性、增加了更多的可能性 加载 .class 文件加载到内存 连接 类和类的关系处理好，.class 加载完成后处理 初始化 2、类加载器深入剖析 Java 虚拟机与程序的生命周期 在如下几种情况下，Java虚拟机将结束生命周期 执行了 System.exit() 方法， 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3、类的加载、连接与初始化 加载：查找并加载类的二进制数据 连接： 验证：去报被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化: 为类的静态变量赋于正确的初始值 4、类的使用和卸载 使用 卸载 加载 =&gt; 连接（验证、准备、解析） =&gt; 初始化 Java 对类的使用方式可以分为2种 主动使用 （7种） 创建类的实例 访问某个类或者接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射 （如 Class.forName(“”)） 初始化一个类的子类 Java 虚拟机启动时被标明为启动类的类（Java Test） JDK1.7 开始提供的动态语言支持java.lang.invoke.MethodHandle实例的解析记过REF_getStatic,REF_putStatic,REF_invokeStatic 句柄对应的类没有初始化，则初始化 注意：除了以上七种情况，其他使用Java类的方式被看作是对类的被动使用， 都不会导致类的初始化 被动使用 所有的Java虚拟机实现必须在每个类或接口被Java程序”首次主动使用” 时才会被加载 类的加载类的加载，是指类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class 对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据库结构 类的加载方式 从本地系统中直接加载 通过网络下载 .class文件 从zip, jar等归档文件中加载 .class 文件 从专有数据库中提取 .class文件","categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}],"keywords":[]}]}